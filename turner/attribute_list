#pragma once // -*- C++ -*-

/**
 * \file turner/attribute_list
 * Attribute types list
 */

#include <pal/result>
#include <tuple>
#include <type_traits>

namespace turner {

/// Attribute types list
template <auto... Attributes>
struct attribute_list
{
	/// Protocol type common to all attribute types.
	///
	/// It is compile-time error to combine attribute types from
	/// different protocol into single list unless protocols are
	/// convertible (like STUN <-> TURN)
	using protocol_type = std::common_type_t<typename decltype(Attributes)::protocol_type...>;

	/// Attributes type list as tuple
	static constexpr auto types = std::make_tuple(Attributes...);

	/// Return index sequence type for Attributes
	static constexpr std::index_sequence_for<decltype(Attributes)...> index_sequence () noexcept
	{
		return {};
	}

	/// Optional values corresponding to this attribute_list
	using read_value_list = std::tuple<
		pal::result<typename decltype(Attributes)::value_type::native_value_type>...
	>;

	/// True if \a Protocol is compatible with protocol_type
	template <typename Protocol>
	static constexpr bool is_compatible_with = std::is_convertible_v<Protocol, protocol_type>;

	/// Returns true if attributes list contain \a type
	static constexpr bool contains (uint16_t type) noexcept
	{
		return contains(type, index_sequence());
	}

private:

	template <size_t... I>
	static constexpr bool contains (uint16_t type, std::index_sequence<I...>) noexcept
	{
		return ((std::tuple_element_t<I, decltype(types)>::type == type) || ...);
	}
};

/// Convenience instance to declare attribute_list as variable
template <auto... Attributes>
constexpr attribute_list<Attributes...> attributes;

} // namespace turner
