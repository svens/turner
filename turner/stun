#pragma once // -*- C++ -*-

/**
 * \file turner/stun
 * STUN protocol
 */

#include <turner/__bits/lib>
#include <turner/attribute_type>
#include <turner/attribute_value_type>
#include <turner/basic_message_reader>
#include <turner/message_type>
#include <pal/result>
#include <array>
#include <span>


__turner_begin


/**
 * STUN protocol requests/attributes
 *
 * \see https://datatracker.ietf.org/doc/html/rfc8489
 *
 * \note Missing attribute types:
 * - static constexpr attribute_type<stun, T> message_integrity_sha256 = 0x001c;
 * - static constexpr attribute_type<stun, T> password_algorithm = 0x001d;
 * - static constexpr attribute_type<stun, T> userhash = 0x001e;
 * - static constexpr attribute_type<stun, T> password_algorithms = 0x8002;
 */
struct stun
{
	/// STUN message header size
	static constexpr size_t header_size_bytes = 20;

	/// STUN message attribute padding boundary
	static constexpr size_t pad_size_bytes = 4;

	/// Magic Cookie offset from beginning of message
	static constexpr size_t cookie_offset = 4;

	/// STUN message cookie type
	using cookie_type = std::array<uint8_t, 4>;

	/// STUN message Magic Cookie value
	static constexpr cookie_type magic_cookie = { 0x21, 0x12, 0xa4, 0x42, };

	/// Transaction ID offset from beginning of message
	static constexpr size_t transaction_id_offset = 8;

	/// STUN message transaction ID type
	using transaction_id_type = std::array<uint8_t, 12>;

	/// Generic STUN message reader
	using message_reader = basic_message_reader<stun>;

	/**
	 * \defgroup STUN_Methods STUN Method registry
	 * \see https://datatracker.ietf.org/doc/html/rfc8489#section-18.2
	 * \{
	 */

	/// STUN Binding request
	static constexpr message_type<stun> binding = 0x0001;

	/// STUN Binding request success response
	static constexpr auto binding_success = binding.success_response();

	/// \}

	/// \cond
	struct no_endpoint_map
	{
		template <typename OtherProtocol>
		requires(std::is_convertible_v<OtherProtocol, stun>)
		static void transform (
			const basic_message_reader<OtherProtocol> &,
			pal::net::ip::address &,
			pal::net::ip::port_type &) noexcept
		{ }
	};
	using endpoint_value_type = turner::endpoint_value_type<no_endpoint_map>;

	struct xor_endpoint_map
	{
		template <typename OtherProtocol>
		requires(std::is_convertible_v<OtherProtocol, stun>)
		static void transform (
			const basic_message_reader<OtherProtocol> &message,
			pal::net::ip::address &address,
			pal::net::ip::port_type &port) noexcept
		{
			(void)message;
			(void)address;
			(void)port;
		}
	};
	using xor_endpoint_value_type = turner::endpoint_value_type<xor_endpoint_map>;
	/// \endcond

	/**
	 * \defgroup STUN_Attributes STUN Attribute Registry
	 * \see https://datatracker.ietf.org/doc/html/rfc8489#section-18.3
	 * \{
	 */

	/// \see https://datatracker.ietf.org/doc/html/rfc8489#section-14.1
	static constexpr attribute_type<stun, endpoint_value_type> mapped_address = 0x0001;

	/// \see https://datatracker.ietf.org/doc/html/rfc8489#section-14.3
	static constexpr attribute_type<stun, string_value_type<513>> username = 0x0006;

	/// \see https://datatracker.ietf.org/doc/html/rfc8489#section-14.5
	static constexpr attribute_type<stun, bytes_value_type<20>> message_integrity = 0x0008;

	/// \see https://datatracker.ietf.org/doc/html/rfc8489#section-14.8
	static constexpr attribute_type<stun, error_code_value_type> error_code = 0x0009;

	/// \see https://datatracker.ietf.org/doc/html/rfc8489#section-14.13
	static constexpr attribute_type<stun, attribute_list_value_type> unknown_attributes = 0x000a;

	/// \see https://datatracker.ietf.org/doc/html/rfc8489#section-14.9
	static constexpr attribute_type<stun, string_value_type<763>> realm = 0x0014;

	/// \see https://datatracker.ietf.org/doc/html/rfc8489#section-14.10
	static constexpr attribute_type<stun, string_value_type<763>> nonce = 0x0015;

	/// \see https://datatracker.ietf.org/doc/html/rfc8489#section-14.2
	static constexpr attribute_type<stun, xor_endpoint_value_type> xor_mapped_address = 0x0020;

	/// \see https://datatracker.ietf.org/doc/html/rfc8489#section-14.16
	static constexpr attribute_type<stun, string_value_type<255>> alternate_domain = 0x8003;

	/// \see https://datatracker.ietf.org/doc/html/rfc8489#section-14.14
	static constexpr attribute_type<stun, string_value_type<763>> software = 0x8022;

	/// \see https://datatracker.ietf.org/doc/html/rfc8489#section-14.15
	static constexpr attribute_type<stun, endpoint_value_type> alternate_server = 0x8023;

	/// \see https://datatracker.ietf.org/doc/html/rfc8489#section-14.7
	static constexpr attribute_type<stun, uint32_value_type> fingerprint = 0x8028;

	/// \}

	/**
	 * Validates \a span contains STUN message and returns generic message reader
	 *
	 * \note This method does not check for known STUN message/attribute types,
	 * only message structure validity.
	 *
	 * \see https://datatracker.ietf.org/doc/html/rfc8489#section-5
	 */
	static pal::result<message_reader> read_message (std::span<const std::byte> span) noexcept;
};


__turner_end
