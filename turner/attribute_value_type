#pragma once // -*- C++ -*-

/**
 * \file turner/attribute_value_type
 * Attribute value reader/writer
 */

#include <turner/__bits/lib>
#include <turner/error>
#include <turner/fwd>
#include <turner/protocol_error>
#include <pal/byte_order>
#include <pal/result>
#include <array>
#include <chrono>
#include <span>
#include <string_view>


__turner_begin


/// Generic uint32_t type attribute value reader/writer
struct uint32_value_type
{
	/// Native value type
	using value_type = uint32_t;

	/// Read attribute value from \a span
	template <typename Protocol>
	static pal::result<value_type> read (
		const basic_message_reader<Protocol> &,
		std::span<const std::byte> span) noexcept
	{
		if (span.size_bytes() == sizeof(value_type))
		{
			return pal::ntoh(*reinterpret_cast<const value_type *>(span.data()));
		}
		return make_unexpected(errc::unexpected_attribute_length);
	}
};


/// Generic std::chrono::seconds type attribute value reader/writer
struct seconds_value_type
{
	/// Native value type
	using value_type = std::chrono::seconds;

	/// Read attribute value from \a span
	template <typename Protocol>
	static pal::result<value_type> read (
		const basic_message_reader<Protocol> &message,
		std::span<const std::byte> span) noexcept
	{
		return uint32_value_type::read(message, span).map([](auto value)
		{
			return value_type{value};
		});
	}
};


/// Generic std::string_view type attribute value reader/writer
template <size_t MaxSizeBytes = std::dynamic_extent>
struct string_value_type
{
	/// Native value type
	using value_type = std::string_view;

	/**
	 * Read attribute value from \a span
	 *
	 * \note returned std::string_view does not own specified range, it
	 * points into \a span. Caller should copy value if needed.
	 */
	template <typename Protocol>
	static pal::result<value_type> read (
		const basic_message_reader<Protocol> &,
		std::span<const std::byte> span) noexcept
	{
		if constexpr (MaxSizeBytes != std::dynamic_extent)
		{
			if (span.size_bytes() > MaxSizeBytes)
			{
				return make_unexpected(errc::unexpected_attribute_length);
			}
		}
		return value_type{
			reinterpret_cast<const char *>(span.data()),
			span.size_bytes()
		};
	}
};


/// Generic std::span<std::byte, Extent> type attribute value reader/writer
template <size_t Extent = std::dynamic_extent>
struct bytes_value_type
{
	/// Native value type
	using value_type = std::span<const std::byte, Extent>;

	/**
	 * Read attribute value from \a span
	 *
	 * \note returned std::span does not own specified range, it
	 * points into \a span. Caller should copy value if needed.
	 */
	template <typename Protocol>
	static pal::result<value_type> read (
		const basic_message_reader<Protocol> &,
		std::span<const std::byte> span) noexcept
	{
		if constexpr (Extent != std::dynamic_extent)
		{
			if (span.size_bytes() != Extent)
			{
				return make_unexpected(errc::unexpected_attribute_length);
			}
		}
		return value_type{span};
	}
};


/// Generic protocol error type attribute value reader/writer
struct error_code_value_type
{
	/// Native value type
	using value_type = std::tuple<protocol_errc, std::string_view>;

	/**
	 * Read attribute value from \a span
	 *
	 * \note returned tuple 2nd field does not own specified range, it
	 * points into \a span. Caller should copy value if needed.
	 */
	template <typename Protocol>
	static pal::result<value_type> read (
		const basic_message_reader<Protocol> &,
		std::span<const std::byte> span) noexcept
	{
		static constexpr auto code_size_bytes = 4 * sizeof(uint8_t);
		if (span.size_bytes() >= code_size_bytes)
		{
			auto code = reinterpret_cast<const uint8_t *>(span.data());
			return value_type{
				(protocol_errc)((code[2] & 0b0000'0111) * 100 + code[3]),
				std::string_view{
					reinterpret_cast<const char *>(span.data() + code_size_bytes),
					span.size_bytes() - code_size_bytes
				}
			};
		}
		return make_unexpected(errc::unexpected_attribute_length);
	}
};


/**
 * Generic attribute type values list reader/writer.
 *
 * \note value_type supports up to 4 elements even though underlying Protocol
 * does not limit this number. If attribute in \a span contains more elements,
 * only up to 4 are copied but returned tuple<0> field reflects actual number.
 */
struct attribute_list_value_type
{
	/// Native value type
	using value_type = std::tuple<size_t, std::array<uint16_t, 4>>;

	/**
	 * Read attribute value from \a span.
	 *
	 * \note returned std::span does not own specified range, it points
	 * into \a span. Caller should copy value if needed. Values are in
	 * network byte order.
	 */
	template <typename Protocol>
	static pal::result<value_type> read (
		const basic_message_reader<Protocol> &,
		std::span<const std::byte> span) noexcept
	{
		auto size = span.size_bytes() / sizeof(uint16_t);
		if (size * sizeof(uint16_t) == span.size_bytes())
		{
			value_type result{size, {}};
			auto &dest = std::get<1>(result);
			size = (std::min)(size, dest.max_size());
			auto *src = reinterpret_cast<const uint16_t *>(span.data());
			std::transform(src, src + size, dest.begin(), ntoh);
			return result;
		}

		return make_unexpected(errc::unexpected_attribute_length);
	}


private:

	static constexpr auto ntoh = [](uint16_t v)
	{
		return pal::ntoh(v);
	};
};


__turner_end
