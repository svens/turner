#pragma once // -*- C++ -*-

/**
 * \file turner/attribute_value_type
 * Attribute value reader/writer
 */

#include <turner/__bits/lib>
#include <turner/error>
#include <turner/fwd>
#include <turner/protocol_error>
#include <pal/byte_order>
#include <pal/net/ip/address>
#include <pal/net/ip/basic_endpoint>
#include <pal/result>
#include <array>
#include <chrono>
#include <span>
#include <string_view>


__turner_begin


/// Generic uint32_t type attribute value reader/writer
struct uint32_value_type
{
	/// Native value type
	using value_type = uint32_t;

	/// Read attribute value from \a span
	template <typename Protocol>
	static pal::result<value_type> read (
		const basic_message_reader<Protocol> &,
		std::span<const std::byte> span) noexcept
	{
		if (span.size_bytes() == sizeof(value_type))
		{
			return pal::ntoh(*reinterpret_cast<const value_type *>(span.data()));
		}
		return make_unexpected(errc::unexpected_attribute_length);
	}
};


/// Generic std::chrono::seconds type attribute value reader/writer
struct seconds_value_type
{
	/// Native value type
	using value_type = std::chrono::seconds;

	/// Read attribute value from \a span
	template <typename Protocol>
	static pal::result<value_type> read (
		const basic_message_reader<Protocol> &message,
		std::span<const std::byte> span) noexcept
	{
		return uint32_value_type::read(message, span).map([](auto value)
		{
			return value_type{value};
		});
	}
};


/// Address family values for STUN/TURN/MS-TURN protocols
enum class address_family: uint8_t
{
	v4 = 0x01, ///< IPv4
	v6 = 0x02, ///< IPv6
};


/// Address family attribute value reader/writer
struct address_family_value_type
{
	/// Native value type
	using value_type = address_family;

	/// Read attribute value from \a span
	template <typename Protocol>
	static pal::result<value_type> read (
		const basic_message_reader<Protocol> &,
		std::span<const std::byte> span) noexcept
	{
		if (span.size_bytes() == sizeof(uint32_t))
		{
			auto v = *reinterpret_cast<const value_type *>(span.data());
			if (v == address_family::v4 || v == address_family::v6)
			{
				return v;
			}
			return make_unexpected(errc::unexpected_attribute_value);
		}
		return make_unexpected(errc::unexpected_attribute_length);
	}
};


/// EVEN-PORT attribute value reader/writer
struct even_port_value_type
{
	/// Native value type
	using value_type = bool;

	/// Read attribute value from \a span
	template <typename Protocol>
	static pal::result<value_type> read (
		const basic_message_reader<Protocol> &,
		std::span<const std::byte> span) noexcept
	{
		if (span.size_bytes() == 1)
		{
			static constexpr uint8_t r = 0b1000'0000;
			auto v = *reinterpret_cast<const uint8_t *>(span.data());
			return (v & r) == r;
		}
		return make_unexpected(errc::unexpected_attribute_length);
	}
};


/// Transport protocol for allocated transport address
/// \see https://www.iana.org/assignments/protocol-numbers
enum class transport_protocol: uint8_t
{
	tcp = 6,
	udp = 17,
};


/// Transport protocol attribute value reader/writer
struct transport_protocol_value_type
{
	/// Native value type
	using value_type = transport_protocol;

	/// Read attribute value from \a span
	template <typename Protocol>
	static pal::result<value_type> read (
		const basic_message_reader<Protocol> &,
		std::span<const std::byte> span) noexcept
	{
		if (span.size_bytes() == sizeof(uint32_t))
		{
			auto v = *reinterpret_cast<const value_type *>(span.data());
			if (v == transport_protocol::udp || v == transport_protocol::tcp)
			{
				return v;
			}
			return make_unexpected(errc::unexpected_attribute_value);
		}
		return make_unexpected(errc::unexpected_attribute_length);
	}
};


/// DONT-FRAGMENT attribute value reader/writer
struct dont_fragment_value_type
{
	/// Native value type
	using value_type = bool;

	/// Read attribute value from \a span
	template <typename Protocol>
	static pal::result<value_type> read (
		const basic_message_reader<Protocol> &,
		std::span<const std::byte> span) noexcept
	{
		if (span.size_bytes() == 0)
		{
			// simply attribute existence -> true
			return true;
		}
		return make_unexpected(errc::unexpected_attribute_length);
	}
};


/// Generic std::string_view type attribute value reader/writer
template <size_t MaxSizeBytes = std::dynamic_extent>
struct string_value_type
{
	/// Native value type
	using value_type = std::string_view;

	/**
	 * Read attribute value from \a span
	 *
	 * \note returned std::string_view does not own specified range, it
	 * points into \a span. Caller should copy value if needed.
	 */
	template <typename Protocol>
	static pal::result<value_type> read (
		const basic_message_reader<Protocol> &,
		std::span<const std::byte> span) noexcept
	{
		if constexpr (MaxSizeBytes != std::dynamic_extent)
		{
			if (span.size_bytes() > MaxSizeBytes)
			{
				return make_unexpected(errc::unexpected_attribute_length);
			}
		}
		return value_type{
			reinterpret_cast<const char *>(span.data()),
			span.size_bytes()
		};
	}
};


/// Generic std::span<std::byte, Extent> type attribute value reader/writer
template <size_t Extent = std::dynamic_extent>
struct bytes_value_type
{
	/// Native value type
	using value_type = std::span<const std::byte, Extent>;

	/**
	 * Read attribute value from \a span
	 *
	 * \note returned std::span does not own specified range, it
	 * points into \a span. Caller should copy value if needed.
	 */
	template <typename Protocol>
	static pal::result<value_type> read (
		const basic_message_reader<Protocol> &,
		std::span<const std::byte> span) noexcept
	{
		if constexpr (Extent != std::dynamic_extent)
		{
			if (span.size_bytes() != Extent)
			{
				return make_unexpected(errc::unexpected_attribute_length);
			}
		}
		return value_type{span};
	}
};


/// Generic protocol error type attribute value reader/writer
struct error_code_value_type
{
	/// Native value type
	using value_type = std::tuple<protocol_errc, std::string_view>;

	/**
	 * Read attribute value from \a span
	 *
	 * \note returned tuple 2nd field does not own specified range, it
	 * points into \a span. Caller should copy value if needed.
	 */
	template <typename Protocol>
	static pal::result<value_type> read (
		const basic_message_reader<Protocol> &,
		std::span<const std::byte> span) noexcept
	{
		static constexpr auto code_size_bytes = 4 * sizeof(uint8_t);
		if (span.size_bytes() >= code_size_bytes)
		{
			auto code = reinterpret_cast<const uint8_t *>(span.data());
			return value_type{
				(protocol_errc)((code[2] & 0b0000'0111) * 100 + code[3]),
				std::string_view{
					reinterpret_cast<const char *>(span.data() + code_size_bytes),
					span.size_bytes() - code_size_bytes
				}
			};
		}
		return make_unexpected(errc::unexpected_attribute_length);
	}
};


/**
 * Generic attribute type values list reader/writer.
 *
 * \note value_type supports up to 4 elements even though underlying Protocol
 * does not limit this number. If attribute in \a span contains more elements,
 * only up to 4 are copied but returned tuple<0> field reflects actual number.
 */
struct attribute_list_value_type
{
	/// Native value type
	using value_type = std::tuple<size_t, std::array<uint16_t, 4>>;

	/**
	 * Read attribute value from \a span.
	 *
	 * \note returned std::span does not own specified range, it points
	 * into \a span. Caller should copy value if needed. Values are in
	 * network byte order.
	 */
	template <typename Protocol>
	static pal::result<value_type> read (
		const basic_message_reader<Protocol> &,
		std::span<const std::byte> span) noexcept
	{
		auto size = span.size_bytes() / sizeof(uint16_t);
		if (size * sizeof(uint16_t) == span.size_bytes())
		{
			value_type result{size, {}};
			auto &dest = std::get<1>(result);
			size = (std::min)(size, dest.max_size());
			auto *src = reinterpret_cast<const uint16_t *>(span.data());
			std::transform(src, src + size, dest.begin(), ntoh);
			return result;
		}

		return make_unexpected(errc::unexpected_attribute_length);
	}


private:

	static constexpr auto ntoh = [](uint16_t v)
	{
		return pal::ntoh(v);
	};
};


/**
 * Internet address/port pair type value reader/writer.
 *
 * Template argument Map is endpoint transformer before returning value to
 * caller. STUN/TURN/MS-TURN currently support XOR transformation. For simple
 * endpoints, protocols use no-op handler.
 */
template <typename Map>
struct basic_endpoint_value_type
{
	/// Native value type
	using value_type = std::tuple<pal::net::ip::address, pal::net::ip::port_type>;

	/// Read attribute value from \a span
	template <typename Protocol>
	static pal::result<value_type> read (
		const basic_message_reader<Protocol> &message,
		std::span<const std::byte> span) noexcept
	{
		if (span.size_bytes() == 8)
		{
			return read_ipv4(span).and_then(map_with(message));
		}
		else if (span.size_bytes() == 20)
		{
			return read_ipv6(span).and_then(map_with(message));
		}
		return make_unexpected(errc::unexpected_attribute_length);
	}

private:

	static uint8_t family (const std::span<const std::byte> &span) noexcept
	{
		return reinterpret_cast<const uint8_t *>(span.data())[1];
	}

	static pal::net::ip::port_type port (const std::span<const std::byte> &span) noexcept
	{
		return reinterpret_cast<const uint16_t *>(span.data())[1];
	}

	template <typename Address>
	static pal::net::ip::address address (const std::span<const std::byte> &span) noexcept
	{
		return Address{*reinterpret_cast<const typename Address::bytes_type *>(span.data() + 4)};
	}

	static pal::result<value_type> read_ipv4 (const std::span<const std::byte> &span) noexcept
	{
		if (family(span) == 0x01)
		{
			return value_type{address<pal::net::ip::address_v4>(span), port(span)};
		}
		return make_unexpected(errc::unexpected_attribute_value);
	}

	static pal::result<value_type> read_ipv6 (const std::span<const std::byte> &span) noexcept
	{
		if (family(span) == 0x02)
		{
			return value_type{address<pal::net::ip::address_v6>(span), port(span)};
		}
		return make_unexpected(errc::unexpected_attribute_value);
	}

	template <typename Protocol>
	static auto map_with (const basic_message_reader<Protocol> &message) noexcept
	{
		return [&](value_type &&endpoint) -> pal::result<value_type>
		{
			auto &port = std::get<1>(endpoint);
			Map::transform(message, std::get<0>(endpoint), port);
			port = pal::ntoh(port);
			return std::move(endpoint);
		};
	}
};


namespace __bits {

// below, Protocol vs OtherProtocol is for STUN <- TURN inheritance

template <typename Protocol>
struct no_endpoint_map
{
	template <typename OtherProtocol>
	requires(std::is_convertible_v<OtherProtocol, Protocol>)
	static void transform (
		const basic_message_reader<OtherProtocol> &,
		pal::net::ip::address &,
		pal::net::ip::port_type &) noexcept
	{ }
};

template <typename Protocol>
struct xor_endpoint_map
{
	template <typename OtherProtocol>
	requires(std::is_convertible_v<OtherProtocol, Protocol>)
	static void transform (
		const basic_message_reader<OtherProtocol> &message,
		pal::net::ip::address &address,
		pal::net::ip::port_type &port) noexcept
	{
		// - MS-TURN: 16B Transaction ID
		// - TURN: 4B Magic Cookie + 12B Transaction ID
		auto &xor_value = *reinterpret_cast<const std::array<uint8_t, 16> *>(
			message.as_bytes().data() + 4
		);

		port ^= *reinterpret_cast<const uint16_t *>(xor_value.data());
		if (address.is_v4())
		{
			auto &in = *const_cast<in_addr *>(
				reinterpret_cast<const in_addr *>(address.v4().to_bytes().data())
			);
			in.s_addr ^= *reinterpret_cast<const uint32_t *>(xor_value.data());
		}
		else
		{
			auto &in = *const_cast<in6_addr *>(
				reinterpret_cast<const in6_addr *>(address.v6().to_bytes().data())
			);
			for (auto i = 0u;  i < xor_value.max_size();  ++i)
			{
				in.s6_addr[i] ^= xor_value[i];
			}
		}
	}
};

} // namespace __bits


/**
 * Internet address/port pair type value reader/writer.
 *
 * \see basic_endpoint_value_type<>
 */
template <typename Protocol>
using endpoint_value_type = basic_endpoint_value_type<__bits::no_endpoint_map<Protocol>>;

/**
 * Internet address/port pair type value reader/writer.
 *
 * Value is obfuscated using XOR operation. While STUN and MS-TURN document
 * different values for XORing, in practise both refer to same region in
 * message. This allows to have single implementation for both protocols.
 *
 * \see basic_endpoint_value_type<>
 */
template <typename Protocol>
using xor_endpoint_value_type = basic_endpoint_value_type<__bits::xor_endpoint_map<Protocol>>;


__turner_end
